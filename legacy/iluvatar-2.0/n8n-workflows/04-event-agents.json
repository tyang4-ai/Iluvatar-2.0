{
  "name": "ILUVATAR Event Agents (Tier 2)",
  "active": true,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "event/context-warning",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "shadowfax-webhook",
      "name": "Shadowfax Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        250,
        100
      ],
      "webhookId": "shadowfax-context-warning"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "event/file-written",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "galadriel-webhook",
      "name": "Galadriel Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        250,
        400
      ],
      "webhookId": "galadriel-file-written"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "event/test-failed",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "elrond-webhook",
      "name": "Elrond Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        250,
        700
      ],
      "webhookId": "elrond-test-failed"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "event/pre-submission",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "faramir-webhook",
      "name": "Faramir Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        250,
        1000
      ],
      "webhookId": "faramir-pre-submission"
    },
    {
      "parameters": {
        "functionCode": "// Initialize Shadowfax context compression\nconst hackathonId = $input.first().json.hackathon_id;\nconst agent = $input.first().json.agent;\nconst usagePercent = $input.first().json.usagePercent || '80%';\nconst inputTokens = $input.first().json.input_tokens || 0;\nconst contextLimit = $input.first().json.context_limit || 200000;\n\n// Connect to Redis to get current context\nconst Redis = require('ioredis');\nconst redis = new Redis({\n  host: '127.0.0.1',\n  port: 6379\n});\n\ntry {\n  // Get current hackathon context\n  const context = await redis.hgetall(`hackathon:${hackathonId}:context`);\n  const stateData = await redis.hgetall(`hackathon:${hackathonId}:state`);\n  \n  return [{\n    json: {\n      hackathon_id: hackathonId,\n      triggered_by: agent,\n      usage_percent: usagePercent,\n      input_tokens: inputTokens,\n      context_limit: contextLimit,\n      current_context: context,\n      current_state: stateData,\n      compression_needed: true\n    }\n  }];\n} finally {\n  await redis.quit();\n}"
      },
      "id": "shadowfax-init",
      "name": "Initialize Shadowfax",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        500,
        100
      ]
    },
    {
      "parameters": {
        "functionCode": "// Load Shadowfax prompt (inlined)\nconst systemPrompt = `You are Shadowfax, the context compression agent.\n\nYour role is to compress conversation context while preserving:\n1. Key decisions made\n2. Critical code snippets\n3. Architecture choices\n4. Current progress state\n5. Blocking issues\n\nOutput JSON with:\n- compressed_context: The compressed version\n- summary: Brief summary of what was preserved\n- tokens_saved: Estimated tokens saved\n- key_decisions: Array of important decisions`;\n\nconst context = $input.first().json;\n\nreturn [{\n  json: {\n    ...context,\n    system_prompt: systemPrompt\n  }\n}];"
      },
      "id": "shadowfax-load-prompt",
      "name": "Load Shadowfax Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        750,
        100
      ]
    },
    {
      "parameters": {
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $env.ANTHROPIC_API_KEY }}"
            },
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-haiku-20240307\",\n  \"max_tokens\": 4096,\n  \"system\": {{ JSON.stringify($json.system_prompt) }},\n  \"messages\": [{\n    \"role\": \"user\",\n    \"content\": \"Compress this context while preserving critical information:\\n\\nCurrent Context: \" + JSON.stringify($json.current_context) + \"\\n\\nCurrent State: \" + JSON.stringify($json.current_state) + \"\\n\\nUsage: \" + $json.usage_percent + \" of context limit\\n\\nOutput valid JSON only.\"\n  }]\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "shadowfax-call-claude",
      "name": "Call Claude (Shadowfax)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1000,
        100
      ]
    },
    {
      "parameters": {
        "functionCode": "// Parse Shadowfax output and update Redis\nconst Redis = require('ioredis');\nconst redis = new Redis({\n  host: '127.0.0.1',\n  port: 6379\n});\n\nconst hackathonId = $('Initialize Shadowfax').first().json.hackathon_id;\nconst response = $input.first().json;\n\ntry {\n  // Extract text content from Claude response\n  let content = '';\n  if (response.content && Array.isArray(response.content)) {\n    content = response.content.filter(c => c.type === 'text').map(c => c.text).join('');\n  }\n  \n  // Parse JSON from response\n  let parsed;\n  const jsonMatch = content.match(/```json\\s*([\\s\\S]*?)\\s*```/) || content.match(/(\\{[\\s\\S]*\\})/);\n  if (jsonMatch) {\n    parsed = JSON.parse(jsonMatch[1]);\n  } else {\n    parsed = JSON.parse(content);\n  }\n  \n  // Store compressed context\n  await redis.hset(`hackathon:${hackathonId}:context`, 'compressed', JSON.stringify(parsed.compressed_context));\n  await redis.hset(`hackathon:${hackathonId}:state`, 'context_compressed_at', new Date().toISOString());\n  await redis.hset(`hackathon:${hackathonId}:state`, 'tokens_saved', parsed.tokens_saved || 0);\n  \n  // Publish compression complete event\n  await redis.publish('events:context_compressed', JSON.stringify({\n    hackathon_id: hackathonId,\n    tokens_saved: parsed.tokens_saved,\n    timestamp: new Date().toISOString()\n  }));\n  \n  return [{\n    json: {\n      success: true,\n      hackathon_id: hackathonId,\n      compressed_context: parsed.compressed_context,\n      summary: parsed.summary,\n      tokens_saved: parsed.tokens_saved,\n      key_decisions: parsed.key_decisions || []\n    }\n  }];\n} catch (err) {\n  return [{\n    json: {\n      success: false,\n      error: err.message,\n      hackathon_id: hackathonId\n    }\n  }];\n} finally {\n  await redis.quit();\n}"
      },
      "id": "shadowfax-parse-output",
      "name": "Parse Shadowfax Output",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1250,
        100
      ]
    },
    {
      "parameters": {
        "functionCode": "// Initialize Galadriel code review\nconst hackathonId = $input.first().json.hackathon_id;\nconst filePath = $input.first().json.file_path;\nconst fileContent = $input.first().json.content;\nconst cloneId = $input.first().json.clone_id;\nconst fileType = $input.first().json.type || 'backend';\n\nreturn [{\n  json: {\n    hackathon_id: hackathonId,\n    file_path: filePath,\n    file_content: fileContent,\n    clone_id: cloneId,\n    file_type: fileType,\n    review_requested_at: new Date().toISOString()\n  }\n}];"
      },
      "id": "galadriel-init",
      "name": "Initialize Galadriel",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        500,
        400
      ]
    },
    {
      "parameters": {
        "functionCode": "// Load Galadriel prompt (inlined)\nconst systemPrompt = `You are Galadriel, the code review agent.\n\nReview the provided code for:\n1. Code quality and best practices\n2. Security vulnerabilities\n3. Performance issues\n4. Error handling\n5. Readability and maintainability\n\nOutput JSON with:\n- quality_score: 1-10 rating\n- approved: boolean\n- issues: Array of {severity, line, message, fix_suggestion}\n- suggestions: Array of improvement suggestions\n- security_concerns: Array of security issues`;\n\nconst context = $input.first().json;\n\nreturn [{\n  json: {\n    ...context,\n    system_prompt: systemPrompt\n  }\n}];"
      },
      "id": "galadriel-load-prompt",
      "name": "Load Galadriel Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        750,
        400
      ]
    },
    {
      "parameters": {
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $env.ANTHROPIC_API_KEY }}"
            },
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-5-sonnet-20241022\",\n  \"max_tokens\": 4096,\n  \"system\": {{ JSON.stringify($json.system_prompt) }},\n  \"messages\": [{\n    \"role\": \"user\",\n    \"content\": \"Review this {{ $json.file_type }} code:\\n\\nFile: {{ $json.file_path }}\\n\\n```\\n{{ $json.file_content }}\\n```\\n\\nProvide a thorough code review. Output valid JSON only.\"\n  }]\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "galadriel-call-claude",
      "name": "Call Claude (Galadriel)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1000,
        400
      ]
    },
    {
      "parameters": {
        "functionCode": "// Parse Galadriel review and store results\nconst Redis = require('ioredis');\nconst redis = new Redis({\n  host: '127.0.0.1',\n  port: 6379\n});\n\nconst context = $('Initialize Galadriel').first().json;\nconst response = $input.first().json;\n\ntry {\n  let content = '';\n  if (response.content && Array.isArray(response.content)) {\n    content = response.content.filter(c => c.type === 'text').map(c => c.text).join('');\n  }\n  \n  let parsed;\n  const jsonMatch = content.match(/```json\\s*([\\s\\S]*?)\\s*```/) || content.match(/(\\{[\\s\\S]*\\})/);\n  if (jsonMatch) {\n    parsed = JSON.parse(jsonMatch[1]);\n  } else {\n    parsed = JSON.parse(content);\n  }\n  \n  // Store review results\n  await redis.hset(`file:${context.file_path}:review`, {\n    quality_score: parsed.quality_score || 0,\n    approved: parsed.approved ? 'true' : 'false',\n    issues_count: (parsed.issues || []).length,\n    reviewed_at: new Date().toISOString(),\n    reviewed_by: 'galadriel'\n  });\n  \n  // If quality score < 7, request fixes\n  if (parsed.quality_score < 7 && !parsed.approved) {\n    await redis.publish('events:code_needs_fix', JSON.stringify({\n      hackathon_id: context.hackathon_id,\n      file_path: context.file_path,\n      clone_id: context.clone_id,\n      issues: parsed.issues\n    }));\n  }\n  \n  return [{\n    json: {\n      success: true,\n      hackathon_id: context.hackathon_id,\n      file_path: context.file_path,\n      quality_score: parsed.quality_score,\n      approved: parsed.approved,\n      issues: parsed.issues || [],\n      suggestions: parsed.suggestions || [],\n      security_concerns: parsed.security_concerns || []\n    }\n  }];\n} catch (err) {\n  return [{\n    json: {\n      success: false,\n      error: err.message,\n      file_path: context.file_path\n    }\n  }];\n} finally {\n  await redis.quit();\n}"
      },
      "id": "galadriel-parse-output",
      "name": "Parse Galadriel Output",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1250,
        400
      ]
    },
    {
      "parameters": {
        "functionCode": "// Initialize Elrond debug analysis\nconst hackathonId = $input.first().json.hackathon_id;\nconst errorType = $input.first().json.error_type || 'unknown';\nconst errorMessage = $input.first().json.error_message || '';\nconst stackTrace = $input.first().json.stack_trace || '';\nconst filePath = $input.first().json.file_path || '';\nconst testName = $input.first().json.test_name || '';\n\n// Get additional context from Redis\nconst Redis = require('ioredis');\nconst redis = new Redis({\n  host: '127.0.0.1',\n  port: 6379\n});\n\ntry {\n  const recentChanges = await redis.lrange(`hackathon:${hackathonId}:changes`, 0, 10);\n  const fileContent = filePath ? await redis.hget(`file:${filePath}`, 'content') : '';\n  \n  return [{\n    json: {\n      hackathon_id: hackathonId,\n      error_type: errorType,\n      error_message: errorMessage,\n      stack_trace: stackTrace,\n      file_path: filePath,\n      file_content: fileContent,\n      test_name: testName,\n      recent_changes: recentChanges.map(c => JSON.parse(c)),\n      analysis_requested_at: new Date().toISOString()\n    }\n  }];\n} finally {\n  await redis.quit();\n}"
      },
      "id": "elrond-init",
      "name": "Initialize Elrond",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        500,
        700
      ]
    },
    {
      "parameters": {
        "functionCode": "// Load Elrond prompt (inlined)\nconst systemPrompt = `You are Elrond, the debug analysis agent.\n\nAnalyze errors and failures to:\n1. Identify root cause\n2. Propose fixes\n3. Suggest prevention measures\n\nOutput JSON with:\n- diagnosis: What went wrong\n- root_cause: The underlying issue\n- fix_proposal: {file_path, changes, explanation}\n- confidence: 0-1 confidence score\n- debugging_steps: Steps to verify the fix`;\n\nconst context = $input.first().json;\n\nreturn [{\n  json: {\n    ...context,\n    system_prompt: systemPrompt\n  }\n}];"
      },
      "id": "elrond-load-prompt",
      "name": "Load Elrond Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        750,
        700
      ]
    },
    {
      "parameters": {
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $env.ANTHROPIC_API_KEY }}"
            },
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-5-sonnet-20241022\",\n  \"max_tokens\": 4096,\n  \"system\": {{ JSON.stringify($json.system_prompt) }},\n  \"messages\": [{\n    \"role\": \"user\",\n    \"content\": \"Debug this error:\\n\\nError Type: {{ $json.error_type }}\\nError Message: {{ $json.error_message }}\\n\\nStack Trace:\\n{{ $json.stack_trace }}\\n\\nFile: {{ $json.file_path }}\\n\\nFile Content:\\n```\\n{{ $json.file_content }}\\n```\\n\\nRecent Changes: {{ JSON.stringify($json.recent_changes) }}\\n\\nProvide diagnosis and fix. Output valid JSON only.\"\n  }]\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "elrond-call-claude",
      "name": "Call Claude (Elrond)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1000,
        700
      ]
    },
    {
      "parameters": {
        "functionCode": "// Parse Elrond analysis and apply fix if confident\nconst Redis = require('ioredis');\nconst redis = new Redis({\n  host: '127.0.0.1',\n  port: 6379\n});\n\nconst context = $('Initialize Elrond').first().json;\nconst response = $input.first().json;\n\ntry {\n  let content = '';\n  if (response.content && Array.isArray(response.content)) {\n    content = response.content.filter(c => c.type === 'text').map(c => c.text).join('');\n  }\n  \n  let parsed;\n  const jsonMatch = content.match(/```json\\s*([\\s\\S]*?)\\s*```/) || content.match(/(\\{[\\s\\S]*\\})/);\n  if (jsonMatch) {\n    parsed = JSON.parse(jsonMatch[1]);\n  } else {\n    parsed = JSON.parse(content);\n  }\n  \n  // Store debug analysis\n  await redis.hset(`hackathon:${context.hackathon_id}:debug:${Date.now()}`, {\n    error_type: context.error_type,\n    diagnosis: parsed.diagnosis,\n    root_cause: parsed.root_cause || '',\n    confidence: parsed.confidence || 0,\n    analyzed_at: new Date().toISOString()\n  });\n  \n  // If high confidence, publish fix event\n  if (parsed.confidence >= 0.8 && parsed.fix_proposal) {\n    await redis.publish('events:fix_proposed', JSON.stringify({\n      hackathon_id: context.hackathon_id,\n      file_path: parsed.fix_proposal.file_path,\n      changes: parsed.fix_proposal.changes,\n      confidence: parsed.confidence\n    }));\n  }\n  \n  return [{\n    json: {\n      success: true,\n      hackathon_id: context.hackathon_id,\n      diagnosis: parsed.diagnosis,\n      root_cause: parsed.root_cause,\n      fix_proposal: parsed.fix_proposal,\n      confidence: parsed.confidence,\n      debugging_steps: parsed.debugging_steps || [],\n      prevention_recommendations: parsed.prevention_recommendations || []\n    }\n  }];\n} catch (err) {\n  return [{\n    json: {\n      success: false,\n      error: err.message,\n      hackathon_id: context.hackathon_id\n    }\n  }];\n} finally {\n  await redis.quit();\n}"
      },
      "id": "elrond-parse-output",
      "name": "Parse Elrond Output",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1250,
        700
      ]
    },
    {
      "parameters": {
        "functionCode": "// Initialize Faramir quality scoring\nconst hackathonId = $input.first().json.hackathon_id;\n\nconst Redis = require('ioredis');\nconst redis = new Redis({\n  host: '127.0.0.1',\n  port: 6379\n});\n\ntry {\n  // Gather all project information for scoring\n  const state = await redis.hgetall(`hackathon:${hackathonId}:state`);\n  const fileKeys = await redis.keys(`file:*:status`);\n  const files = [];\n  \n  for (const key of fileKeys) {\n    const fileStatus = await redis.hgetall(key);\n    if (fileStatus.hackathon_id === hackathonId) {\n      files.push(fileStatus);\n    }\n  }\n  \n  // Get code review summaries\n  const reviewKeys = await redis.keys(`file:*:review`);\n  const reviews = [];\n  for (const key of reviewKeys) {\n    const review = await redis.hgetall(key);\n    reviews.push(review);\n  }\n  \n  return [{\n    json: {\n      hackathon_id: hackathonId,\n      current_state: state,\n      files_generated: files.length,\n      files_reviewed: reviews.length,\n      review_scores: reviews.map(r => parseFloat(r.quality_score) || 0),\n      average_quality: reviews.length > 0 \n        ? reviews.reduce((sum, r) => sum + (parseFloat(r.quality_score) || 0), 0) / reviews.length \n        : 0,\n      scoring_requested_at: new Date().toISOString()\n    }\n  }];\n} finally {\n  await redis.quit();\n}"
      },
      "id": "faramir-init",
      "name": "Initialize Faramir",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        500,
        1000
      ]
    },
    {
      "parameters": {
        "functionCode": "// Load Faramir prompt (inlined)\nconst systemPrompt = `You are Faramir, the quality scoring agent.\n\nEvaluate project readiness for submission:\n1. Functionality completeness\n2. Code quality\n3. User experience\n4. Innovation\n5. Overall polish\n\nOutput JSON with:\n- overall_score: 1-10 rating\n- go_decision: boolean (ready to submit?)\n- categories: {functionality, code_quality, user_experience, innovation, completeness}\n- strengths: Array of project strengths\n- weaknesses: Array of areas needing improvement\n- blocking_issues: Critical issues that must be fixed`;\n\nconst context = $input.first().json;\n\nreturn [{\n  json: {\n    ...context,\n    system_prompt: systemPrompt\n  }\n}];"
      },
      "id": "faramir-load-prompt",
      "name": "Load Faramir Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        750,
        1000
      ]
    },
    {
      "parameters": {
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $env.ANTHROPIC_API_KEY }}"
            },
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-5-sonnet-20241022\",\n  \"max_tokens\": 4096,\n  \"system\": {{ JSON.stringify($json.system_prompt) }},\n  \"messages\": [{\n    \"role\": \"user\",\n    \"content\": \"Score this project for submission readiness:\\n\\nProject State: {{ JSON.stringify($json.current_state) }}\\n\\nFiles Generated: {{ $json.files_generated }}\\nFiles Reviewed: {{ $json.files_reviewed }}\\nAverage Code Quality Score: {{ $json.average_quality }}\\n\\nProvide comprehensive quality assessment. Output valid JSON only.\"\n  }]\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "faramir-call-claude",
      "name": "Call Claude (Faramir)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1000,
        1000
      ]
    },
    {
      "parameters": {
        "functionCode": "// Parse Faramir scoring and make go/no-go decision\nconst Redis = require('ioredis');\nconst redis = new Redis({\n  host: '127.0.0.1',\n  port: 6379\n});\n\nconst context = $('Initialize Faramir').first().json;\nconst response = $input.first().json;\n\ntry {\n  let content = '';\n  if (response.content && Array.isArray(response.content)) {\n    content = response.content.filter(c => c.type === 'text').map(c => c.text).join('');\n  }\n  \n  let parsed;\n  const jsonMatch = content.match(/```json\\s*([\\s\\S]*?)\\s*```/) || content.match(/(\\{[\\s\\S]*\\})/);\n  if (jsonMatch) {\n    parsed = JSON.parse(jsonMatch[1]);\n  } else {\n    parsed = JSON.parse(content);\n  }\n  \n  // Store quality assessment\n  await redis.hset(`hackathon:${context.hackathon_id}:quality`, {\n    overall_score: parsed.overall_score || 0,\n    go_decision: parsed.go_decision ? 'true' : 'false',\n    functionality: parsed.categories?.functionality || 0,\n    code_quality: parsed.categories?.code_quality || 0,\n    user_experience: parsed.categories?.user_experience || 0,\n    innovation: parsed.categories?.innovation || 0,\n    completeness: parsed.categories?.completeness || 0,\n    assessed_at: new Date().toISOString()\n  });\n  \n  // Publish decision event\n  await redis.publish(`events:quality_assessed`, JSON.stringify({\n    hackathon_id: context.hackathon_id,\n    overall_score: parsed.overall_score,\n    go_decision: parsed.go_decision,\n    blocking_issues: parsed.blocking_issues || []\n  }));\n  \n  return [{\n    json: {\n      success: true,\n      hackathon_id: context.hackathon_id,\n      overall_score: parsed.overall_score,\n      go_decision: parsed.go_decision,\n      categories: parsed.categories,\n      strengths: parsed.strengths || [],\n      weaknesses: parsed.weaknesses || [],\n      blocking_issues: parsed.blocking_issues || [],\n      recommendations: parsed.recommendations || []\n    }\n  }];\n} catch (err) {\n  return [{\n    json: {\n      success: false,\n      error: err.message,\n      hackathon_id: context.hackathon_id\n    }\n  }];\n} finally {\n  await redis.quit();\n}"
      },
      "id": "faramir-parse-output",
      "name": "Parse Faramir Output",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1250,
        1000
      ]
    }
  ],
  "connections": {
    "Shadowfax Webhook": {
      "main": [
        [
          {
            "node": "Initialize Shadowfax",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Shadowfax": {
      "main": [
        [
          {
            "node": "Load Shadowfax Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Shadowfax Prompt": {
      "main": [
        [
          {
            "node": "Call Claude (Shadowfax)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Claude (Shadowfax)": {
      "main": [
        [
          {
            "node": "Parse Shadowfax Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Galadriel Webhook": {
      "main": [
        [
          {
            "node": "Initialize Galadriel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Galadriel": {
      "main": [
        [
          {
            "node": "Load Galadriel Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Galadriel Prompt": {
      "main": [
        [
          {
            "node": "Call Claude (Galadriel)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Claude (Galadriel)": {
      "main": [
        [
          {
            "node": "Parse Galadriel Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Elrond Webhook": {
      "main": [
        [
          {
            "node": "Initialize Elrond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Elrond": {
      "main": [
        [
          {
            "node": "Load Elrond Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Elrond Prompt": {
      "main": [
        [
          {
            "node": "Call Claude (Elrond)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Claude (Elrond)": {
      "main": [
        [
          {
            "node": "Parse Elrond Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Faramir Webhook": {
      "main": [
        [
          {
            "node": "Initialize Faramir",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Faramir": {
      "main": [
        [
          {
            "node": "Load Faramir Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Faramir Prompt": {
      "main": [
        [
          {
            "node": "Call Claude (Faramir)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Claude (Faramir)": {
      "main": [
        [
          {
            "node": "Parse Faramir Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "event-agents-v1",
  "id": "4",
  "meta": {
    "instanceId": "iluvatar-event-agents"
  },
  "tags": []
}