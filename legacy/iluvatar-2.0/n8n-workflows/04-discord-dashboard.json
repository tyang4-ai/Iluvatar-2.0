{
  "name": "Discord Dashboard - Real-time Updates",
  "active": true,
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 5
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Schedule Every 5 Minutes",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        250,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Fetch all state data from Redis\nconst Redis = require('ioredis');\nconst redis = new Redis({host: '127.0.0.1', port: 6379});\n\nconst stateData = await redis.hgetall('state:data');\n\n// Parse JSON fields\nconst state = {\n  hackathon_metadata: JSON.parse(stateData.hackathon_metadata || '{}'),\n  phase_progress: JSON.parse(stateData.phase_progress || '{}'),\n  agent_status: JSON.parse(stateData.agent_status || '{}'),\n  file_tracking: JSON.parse(stateData.file_tracking || '{}'),\n  token_usage: JSON.parse(stateData.token_usage || '{}'),\n  time_tracking: JSON.parse(stateData.time_tracking || '{}'),\n  current_checkpoint: stateData.current_checkpoint || null,\n  checkpoint_status: stateData.checkpoint_status || null\n};\n\nawait redis.quit();\n\nreturn {\n  json: {\n    state: state,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "fetch-state",
      "name": "Fetch State from Redis",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        450,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Calculate dashboard metrics\nconst state = $input.item.json.state;\nconst metadata = state.hackathon_metadata || {};\nconst phaseProgress = state.phase_progress || {};\nconst agentStatus = state.agent_status || {};\nconst fileTracking = state.file_tracking || {};\nconst tokenUsage = state.token_usage || {};\nconst timeTracking = state.time_tracking || {};\n\n// Time remaining calculation\nconst deadline = new Date(metadata.deadline || Date.now() + 24*60*60*1000);\nconst now = new Date();\nconst createdAt = new Date(metadata.created_at || Date.now());\nconst timeRemainingMs = Math.max(0, deadline - now);\nconst totalDurationMs = Math.max(1, deadline - createdAt);\nconst timeRemainingHours = Math.floor(timeRemainingMs / (1000 * 60 * 60));\nconst timeRemainingMinutes = Math.floor((timeRemainingMs % (1000 * 60 * 60)) / (1000 * 60));\nconst timeRemainingPercent = Math.min(100, Math.max(0, Math.floor((timeRemainingMs / totalDurationMs) * 100)));\n\n// Budget calculation\nconst budgetAllocated = Number(metadata.budget_allocated) || 100;\nconst budgetSpent = Number(metadata.budget_spent) || 0;\nconst budgetPercent = Math.min(100, Math.floor((budgetSpent / budgetAllocated) * 100));\nconst budgetStatus = budgetPercent < 80 ? 'âœ“' : (budgetPercent < 90 ? 'âš ï¸' : 'ðŸ”´');\n\n// Rate limit tracking structure\nconst rateTracking = tokenUsage.rate_tracking || { current_rate: 0, queued: 0, last_reset: Date.now() };\nconst currentRate = Number(rateTracking.current_rate) || 0;\nconst rateLimit = 50;\nconst ratePercent = Math.min(100, Math.floor((currentRate / rateLimit) * 100));\nconst rateStatus = ratePercent < 80 ? 'âœ“' : 'âš ï¸';\nconst queuedRequests = Number(rateTracking.queued) || 0;\n\n// Active agents\nconst activeAgents = Object.entries(agentStatus)\n  .filter(([agent, status]) => status === 'active')\n  .map(([agent]) => agent);\n\n// Progress calculation - include new phases for submission\nconst phases = ['ideation', 'planning', 'backend', 'frontend', 'integration', 'testing', 'submission', 'deployment'];\nconst completedPhases = phases.filter(p => phaseProgress[p] === 'completed').length;\nconst totalPhases = phases.length;\nconst progressPercent = Math.floor((completedPhases / totalPhases) * 100);\nconst progressBar = 'â–“'.repeat(Math.floor(progressPercent / 5)) + 'â–‘'.repeat(20 - Math.floor(progressPercent / 5));\n\n// Current phase\nconst currentPhase = phases.find(p => phaseProgress[p] === 'in_progress') || \n                     phases.find(p => phaseProgress[p] === 'pending') || \n                     'completed';\n\n// File progress\nconst files = Object.entries(fileTracking);\nconst completedFiles = files.filter(([path, status]) => status === 'completed').length;\nconst totalFiles = Math.max(1, files.length);\n\n// Velocity calculation with type safety\nconst velocityValue = Number(timeTracking.velocity) || 0;\nconst timeElapsed = Math.max(0.1, (now - createdAt) / (1000 * 60 * 60));\nconst predictedFinish = velocityValue > 0 ? \n  new Date(now.getTime() + ((totalFiles - completedFiles) / velocityValue * 60 * 60 * 1000)) : \n  null;\n\nconst onTime = predictedFinish && predictedFinish < deadline;\n\n// Budget by model with defaults\nconst byModel = tokenUsage.by_model || {};\nconst budgetByModel = {\n  opus: Number(byModel.opus) || 0,\n  sonnet: Number(byModel.sonnet) || 0,\n  haiku: Number(byModel.haiku) || 0\n};\n\nreturn {\n  json: {\n    metadata: metadata,\n    time: {\n      remaining_hours: timeRemainingHours,\n      remaining_minutes: timeRemainingMinutes,\n      remaining_percent: timeRemainingPercent,\n      status: timeRemainingPercent < 25 ? 'âš ï¸' : ''\n    },\n    budget: {\n      allocated: budgetAllocated,\n      spent: budgetSpent,\n      percent: budgetPercent,\n      status: budgetStatus,\n      by_model: budgetByModel\n    },\n    rate: {\n      current: currentRate,\n      limit: rateLimit,\n      percent: ratePercent,\n      status: rateStatus,\n      queued: queuedRequests\n    },\n    active_agents: activeAgents,\n    progress: {\n      percent: progressPercent,\n      bar: progressBar,\n      current_phase: currentPhase,\n      phases: phases.map(p => ({\n        name: p,\n        status: phaseProgress[p] || 'pending',\n        icon: phaseProgress[p] === 'completed' ? 'âœ“' : \n              (phaseProgress[p] === 'in_progress' ? 'âŸ³' : 'â§–')\n      }))\n    },\n    files: {\n      completed: completedFiles,\n      total: totalFiles\n    },\n    velocity: {\n      files_per_hour: velocityValue.toFixed(1),\n      predicted_finish: predictedFinish ? predictedFinish.toLocaleString() : 'Calculating...',\n      status: onTime ? 'ON TIME' : (velocityValue === 0 ? 'STARTING' : 'DELAYED')\n    },\n    checkpoint: {\n      current: state.current_checkpoint,\n      status: state.checkpoint_status,\n      time_until_next: '8 minutes'\n    }\n  }\n};"
      },
      "id": "calculate-metrics",
      "name": "Calculate Dashboard Metrics",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        650,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Format dashboard for Discord\nconst metrics = $input.item.json;\n\nconst dashboard = `\nâ”Œâ”€ ILUVATAR Status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Hackathon: ${metrics.metadata.hackathon_name || 'N/A'}          â”‚\nâ”‚ Deadline: ${new Date(metrics.metadata.deadline).toLocaleString('en-US', {month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'})}                   â”‚\nâ”‚ Time Remaining: ${metrics.time.remaining_hours}h ${metrics.time.remaining_minutes}m (${metrics.time.remaining_percent}%)  ${metrics.time.status}             â”‚\nâ”‚ Phase: ${metrics.progress.current_phase.charAt(0).toUpperCase() + metrics.progress.current_phase.slice(1)} (${metrics.velocity.status})       â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Budget: $${metrics.budget.spent.toFixed(2)} / $${metrics.budget.allocated.toFixed(2)} (${metrics.budget.percent}%) ${metrics.budget.status}              â”‚\nâ”‚  â”œâ”€ Opus:   $${metrics.budget.by_model.opus.toFixed(2)}                           â”‚\nâ”‚  â”œâ”€ Sonnet: $${metrics.budget.by_model.sonnet.toFixed(2)}                           â”‚\nâ”‚  â””â”€ Haiku:  $${metrics.budget.by_model.haiku.toFixed(2)}                            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ API Rate: ${metrics.rate.current} req/min (${metrics.rate.percent}% of limit) ${metrics.rate.status}       â”‚\nâ”‚  â”œâ”€ Queued: ${metrics.rate.queued} requests                       â”‚\nâ”‚  â””â”€ Next available: ${(60 / metrics.rate.limit).toFixed(1)}s                     â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Active Agents:                               â”‚\n${metrics.active_agents.length > 0 ? \n  metrics.active_agents.slice(0, 3).map(a => `â”‚  â”œâ”€ ${a}: Working...        â”‚`).join('\\n') : \n  'â”‚  â””â”€ No active agents                         â”‚'}\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Progress: ${metrics.progress.bar} ${metrics.progress.percent}%            â”‚\n${metrics.progress.phases.map(p => `â”‚  ${p.icon} ${p.name.charAt(0).toUpperCase() + p.name.slice(1).padEnd(40)}â”‚`).join('\\n')}\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Velocity: ${metrics.velocity.files_per_hour} files/hour                     â”‚\nâ”‚ Predicted Finish: ${metrics.velocity.predicted_finish.slice(0, 20).padEnd(20)} ${metrics.velocity.status === 'ON TIME' ? 'âœ“' : 'âš ï¸'}        â”‚\nâ”‚ Status: ${metrics.velocity.status.padEnd(30)}                  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n`;\n\nconst checkpointMessage = metrics.checkpoint.current ? \n  `\\nðŸ”” ${metrics.checkpoint.status === 'PENDING' ? 'Checkpoint pending' : 'Next checkpoint'} in ${metrics.checkpoint.time_until_next}: ${metrics.checkpoint.current}` : \n  '';\n\nreturn {\n  json: {\n    dashboard: '```' + dashboard + '```' + checkpointMessage,\n    metrics: metrics\n  }\n};"
      },
      "id": "format-dashboard",
      "name": "Format Dashboard",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        850,
        300
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.DISCORD_WEBHOOK_URL }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({content: $json.dashboard, username: 'ILUVATAR Status', avatar_url: 'https://i.imgur.com/placeholder.png'}) }}"
      },
      "id": "send-dashboard",
      "name": "Send Dashboard to Discord",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1050,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $('Calculate Dashboard Metrics').item.json.budget.percent }}",
              "operation": "larger",
              "value2": 90
            }
          ]
        }
      },
      "id": "check-budget-alert",
      "name": "Check Budget Alert (>90%)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1250,
        300
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.DISCORD_WEBHOOK_URL }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({content: 'ðŸ”´ **BUDGET ALERT** ðŸ”´\\n\\nBudget usage at ' + $('Calculate Dashboard Metrics').item.json.budget.percent + '%. Consider:\\n- Reducing extended thinking tokens\\n- Using Haiku for non-critical tasks\\n- Enabling response caching', username: 'Budget Monitor'}) }}"
      },
      "id": "send-budget-alert",
      "name": "Send Budget Alert",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1450,
        200
      ]
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $('Calculate Dashboard Metrics').item.json.time.remaining_percent }}",
              "operation": "smaller",
              "value2": 25
            }
          ]
        }
      },
      "id": "check-time-alert",
      "name": "Check Time Alert (<25%)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1250,
        500
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.DISCORD_WEBHOOK_URL }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({content: 'â° **TIME ALERT** â°\\n\\nOnly ' + $('Calculate Dashboard Metrics').item.json.time.remaining_percent + '% time remaining. Consider activating crunch mode.', username: 'Time Monitor'}) }}"
      },
      "id": "send-time-alert",
      "name": "Send Time Alert",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1450,
        500
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $('Calculate Dashboard Metrics').item.json.velocity.status }}",
              "value2": "DELAYED"
            }
          ]
        }
      },
      "id": "check-velocity-alert",
      "name": "Check Velocity Alert (Delayed)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1250,
        700
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.DISCORD_WEBHOOK_URL }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({content: 'ðŸŒ **VELOCITY ALERT** ðŸŒ\\n\\nCurrent pace will finish late. Predicted: ' + $('Calculate Dashboard Metrics').item.json.velocity.predicted_finish + '\\n\\nConsider:\\n- Spawning more clones\\n- Reducing scope\\n- Skipping nice-to-haves', username: 'Velocity Monitor'}) }}"
      },
      "id": "send-velocity-alert",
      "name": "Send Velocity Alert",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1450,
        700
      ]
    },
    {
      "parameters": {
        "functionCode": "const Redis = require('ioredis');\nconst redis = new Redis({host: '127.0.0.1', port: 6379});\n\ntry {\n  // Get metrics from earlier node\n  let metrics = {};\n  try {\n    metrics = $('Calculate Dashboard Metrics').item.json;\n  } catch (e) {\n    metrics = items[0].json.metrics || items[0].json;\n  }\n  \n  const score = Date.now();\n  const value = JSON.stringify(metrics);\n  await redis.zadd('dashboard:history', score, value);\n  return items;\n} catch (err) {\n  console.error('Redis ZADD error in Save Dashboard to History:', err.message);\n  throw err;\n} finally {\n  await redis.quit();\n}"
      },
      "id": "save-dashboard-history",
      "name": "Save Dashboard to History",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1050,
        500
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "dashboard-manual",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "manual-dashboard-webhook",
      "name": "Manual Dashboard Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        250,
        900
      ],
      "webhookId": "dashboard-manual"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($('Format Dashboard').item.json.metrics) }}"
      },
      "id": "respond-manual-dashboard",
      "name": "Respond Manual Dashboard",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1650,
        900
      ]
    }
  ],
  "connections": {
    "Schedule Every 5 Minutes": {
      "main": [
        [
          {
            "node": "Fetch State from Redis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch State from Redis": {
      "main": [
        [
          {
            "node": "Calculate Dashboard Metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Dashboard Metrics": {
      "main": [
        [
          {
            "node": "Format Dashboard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Dashboard": {
      "main": [
        [
          {
            "node": "Send Dashboard to Discord",
            "type": "main",
            "index": 0
          },
          {
            "node": "Save Dashboard to History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Dashboard to Discord": {
      "main": [
        [
          {
            "node": "Check Budget Alert (>90%)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check Time Alert (<25%)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check Velocity Alert (Delayed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Budget Alert (>90%)": {
      "main": [
        [
          {
            "node": "Send Budget Alert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Time Alert (<25%)": {
      "main": [
        [
          {
            "node": "Send Time Alert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Velocity Alert (Delayed)": {
      "main": [
        [
          {
            "node": "Send Velocity Alert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Dashboard Trigger": {
      "main": [
        [
          {
            "node": "Fetch State from Redis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Dashboard to History": {
      "main": [
        [
          {
            "node": "Respond Manual Dashboard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-12-14T00:00:00.000Z",
  "versionId": "1"
}