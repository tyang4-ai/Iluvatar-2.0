{
  "name": "ILUVATAR Backend Clone Handler (Gimli)",
  "active": true,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "gimli-clone",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "gimli-webhook",
      "name": "Gimli Clone Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        250,
        300
      ],
      "webhookId": "gimli-clone"
    },
    {
      "parameters": {
        "functionCode": "// Initialize clone and get next task from queue\nconst Redis = require('ioredis');\nconst redis = new Redis({host: '127.0.0.1', port: 6379});\n\nconst cloneId = $input.item.json.body.clone_id;\nconst hackathonId = $input.item.json.body.hackathon_id;\n\nlet task, architecture, relatedFiles;\ntry {\n  // Get next task from backend queue\n  const taskJson = await redis.zpopmin('queue:backend');\n  if (!taskJson || taskJson.length === 0) {\n    await redis.quit();\n    return { json: { status: 'queue_empty', clone_id: cloneId } };\n  }\n\n  task = JSON.parse(taskJson[0]);\n\n  // Get architecture for context\n  architecture = JSON.parse(await redis.hget('state:data', 'architecture_plan') || '{}');\n\n  // Get related files content if they exist\n  relatedFiles = {};\n  if (task.dependencies && Array.isArray(task.dependencies)) {\n    for (const dep of task.dependencies) {\n      const fileContent = await redis.hget('files:content', dep);\n      if (fileContent) {\n        relatedFiles[dep] = fileContent;\n      }\n    }\n  }\n\n  // Mark clone as active\n  await redis.hset(`clone:${cloneId}:status`, 'state', 'processing');\n  await redis.hset(`clone:${cloneId}:status`, 'current_file', task.file_path);\n  await redis.hset(`clone:${cloneId}:status`, 'started_at', Date.now());\n\n  // Mark file as in progress\n  await redis.hset('file_tracking', task.file_path, 'in_progress');\n} catch (err) {\n  console.error('Redis error in init-clone:', err.message);\n  throw new Error(`Redis operation failed: ${err.message}`);\n} finally {\n  await redis.quit();\n}\n\nreturn {\n  json: {\n    clone_id: cloneId,\n    hackathon_id: hackathonId,\n    task: task,\n    architecture: architecture,\n    related_files: relatedFiles,\n    status: 'task_assigned'\n  }\n};"
      },
      "id": "init-clone",
      "name": "Initialize Clone & Get Task",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        450,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.status }}",
              "value2": "queue_empty",
              "operation": "equals"
            }
          ]
        }
      },
      "id": "check-queue-empty",
      "name": "Check Queue Empty",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        650,
        300
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({status: 'idle', clone_id: $json.clone_id, message: 'Queue empty, clone going idle'}) }}"
      },
      "id": "respond-queue-empty",
      "name": "Respond - Queue Empty",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        850,
        200
      ]
    },
    {
      "parameters": {
        "functionCode": "// Load Gimli system prompt and prepare context\nconst systemPrompt = \"You are Gimli, the backend developer. Write robust backend code following best practices.\";\n\nconst task = $input.item.json.task;\nconst architecture = $input.item.json.architecture;\nconst relatedFiles = $input.item.json.related_files;\n\n// Build context from related files\nlet relatedFilesContext = '';\nfor (const [filePath, content] of Object.entries(relatedFiles)) {\n  relatedFilesContext += `\\n\\n### ${filePath}\\n\\`\\`\\`\\n${content}\\n\\`\\`\\``;\n}\n\nreturn {\n  json: {\n    clone_id: $input.item.json.clone_id,\n    hackathon_id: $input.item.json.hackathon_id,\n    task: task,\n    systemPrompt: systemPrompt,\n    input: {\n      architecture: {\n        tech_stack: architecture.tech_stack || {},\n        database_schema: architecture.database_schema || {},\n        api_endpoints: architecture.api_endpoints || []\n      },\n      file_to_generate: task.file_path,\n      requirements: task.requirements || task.description,\n      dependencies: task.dependencies || [],\n      related_files_content: relatedFilesContext,\n      priority: task.priority\n    }\n  }\n};"
      },
      "id": "prepare-gimli-context",
      "name": "Prepare Gimli Context",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        850,
        400
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "x-api-key",
              "value": "={{ $env.ANTHROPIC_API_KEY }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({model: 'claude-opus-4-20250514', max_tokens: 8192, thinking: {type: 'enabled', budget_tokens: 10000}, messages: [{role: 'user', content: $json.systemPrompt + '\\n\\nInput:\\n' + JSON.stringify($json.input)}]}) }}",
        "options": {
          "timeout": 300000
        }
      },
      "id": "call-gimli",
      "name": "Call Gimli (Claude API)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1050,
        400
      ]
    },
    {
      "parameters": {
        "functionCode": "// Parse Gimli output with validation and repair\nconst response = $input.item.json.content.find(c => c.type === 'text')?.text;\n\n// JSON Validation with progressive repair\nasync function parseWithRetry(output) {\n  // Strategy 1: Direct parse\n  try {\n    return JSON.parse(output);\n  } catch (e1) {\n    console.log('Direct parse failed, trying markdown extraction...');\n  }\n\n  // Strategy 2: Extract from markdown code blocks\n  const jsonBlockMatch = output.match(/```json\\s*([\\s\\S]*?)\\s*```/i);\n  if (jsonBlockMatch) {\n    try {\n      return JSON.parse(jsonBlockMatch[1].trim());\n    } catch (e2) {\n      console.log('Markdown extraction failed, trying cleanup...');\n    }\n  }\n\n  // Strategy 3: Find raw JSON object\n  const jsonMatch = output.match(/(\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])/);\n  if (jsonMatch) {\n    let cleaned = jsonMatch[1];\n    cleaned = cleaned.replace(/,\\s*([}\\]])/g, '$1');\n    cleaned = cleaned.replace(/\\/\\/.*$/gm, '');\n    try {\n      return JSON.parse(cleaned);\n    } catch (e3) {\n      console.log('Cleaned parse failed');\n    }\n  }\n\n  const error = new Error('JSON parsing failed after all strategies');\n  error.rawOutput = output.substring(0, 2000);\n  throw error;\n}\n\nlet result;\nconst Redis = require('ioredis');\nconst redis = new Redis({host: '127.0.0.1', port: 6379});\n\ntry {\n  result = await parseWithRetry(response);\n} catch (parseError) {\n  // Emit to circuit breaker\n  await redis.publish('circuit:failure', JSON.stringify({\n    agent: 'Gimli',\n    clone_id: $('Initialize Clone & Get Task').item.json.clone_id,\n    error: parseError.message,\n    rawOutput: parseError.rawOutput,\n    timestamp: Date.now()\n  }));\n  await redis.quit();\n  throw parseError;\n}\n\nawait redis.quit();\n\nreturn {\n  json: {\n    clone_id: $('Initialize Clone & Get Task').item.json.clone_id,\n    hackathon_id: $('Initialize Clone & Get Task').item.json.hackathon_id,\n    task: $('Prepare Gimli Context').item.json.task,\n    result: result,\n    _validation: 'passed'\n  }\n};"
      },
      "id": "parse-gimli-output",
      "name": "Parse Gimli Output",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1250,
        400
      ]
    },
    {
      "parameters": {
        "functionCode": "// Validate imports using import-checker\nconst { checkImports } = require('/data/core/import-checker');\n\nconst result = $input.item.json.result;\nconst code = result.code;\nconst language = result.language || 'javascript';\n\nlet importValidation = { valid: true, errors: [] };\n\ntry {\n  // Run import checker\n  const checkResult = await checkImports(code, {\n    language: language,\n    projectRoot: '/workspace'\n  });\n\n  if (checkResult.missing && checkResult.missing.length > 0) {\n    importValidation.valid = false;\n    importValidation.errors = checkResult.missing.map(m => ({\n      type: 'missing_import',\n      import: m.import,\n      suggestion: m.suggestion\n    }));\n  }\n\n  if (checkResult.unresolved && checkResult.unresolved.length > 0) {\n    importValidation.valid = false;\n    importValidation.errors.push(...checkResult.unresolved.map(u => ({\n      type: 'unresolved_import',\n      import: u.import,\n      reason: u.reason\n    })));\n  }\n} catch (err) {\n  console.warn('Import check failed:', err.message);\n  // Don't fail the whole process for import check errors\n  importValidation.warning = err.message;\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    import_validation: importValidation\n  }\n};"
      },
      "id": "validate-imports",
      "name": "Validate Imports",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1450,
        400
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.import_validation.valid }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-imports-valid",
      "name": "Check Imports Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1650,
        400
      ]
    },
    {
      "parameters": {
        "functionCode": "// Route to Merry for help fixing imports\nconst Redis = require('ioredis');\nconst redis = new Redis({host: '127.0.0.1', port: 6379});\n\ntry {\n  await redis.publish('agent:Merry', JSON.stringify({\n    from: 'Gimli',\n    type: 'import_fix_request',\n    clone_id: $input.item.json.clone_id,\n    file_path: $input.item.json.result.file_path,\n    code: $input.item.json.result.code,\n    errors: $input.item.json.import_validation.errors,\n    priority: 'high'\n  }));\n\n  // Update file tracking\n  await redis.hset('file_tracking', $input.item.json.result.file_path, 'import_fix_pending');\n} catch (err) {\n  console.error('Redis error:', err.message);\n} finally {\n  await redis.quit();\n}\n\nreturn {\n  json: {\n    status: 'routed_to_merry',\n    clone_id: $input.item.json.clone_id,\n    file_path: $input.item.json.result.file_path,\n    import_errors: $input.item.json.import_validation.errors\n  }\n};"
      },
      "id": "route-to-merry",
      "name": "Route to Merry for Import Fix",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1850,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Write file to container and update tracking\nconst Redis = require('ioredis');\nconst redis = new Redis({host: '127.0.0.1', port: 6379});\nconst fs = require('fs').promises;\nconst path = require('path');\n\nconst result = $input.item.json.result;\nconst filePath = result.file_path;\nconst code = result.code;\n\ntry {\n  // Write to container volume (mounted at /workspace)\n  const fullPath = path.join('/workspace', filePath);\n  const dir = path.dirname(fullPath);\n\n  // Ensure directory exists\n  await fs.mkdir(dir, { recursive: true });\n\n  // Write the file\n  await fs.writeFile(fullPath, code, 'utf8');\n\n  // Store content in Redis for other clones to reference\n  await redis.hset('files:content', filePath, code);\n\n  // Update file tracking\n  await redis.hset('file_tracking', filePath, 'written');\n\n  // Update clone status\n  await redis.hset(`clone:${$input.item.json.clone_id}:status`, 'files_completed', \n    (parseInt(await redis.hget(`clone:${$input.item.json.clone_id}:status`, 'files_completed') || '0') + 1).toString()\n  );\n\n  console.log(`File written: ${filePath}`);\n} catch (err) {\n  console.error('File write error:', err.message);\n  await redis.hset('file_tracking', filePath, 'write_failed');\n  throw new Error(`Failed to write file: ${err.message}`);\n} finally {\n  await redis.quit();\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    file_written: true,\n    file_path: filePath\n  }\n};"
      },
      "id": "write-to-container",
      "name": "Write File to Container",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1850,
        500
      ]
    },
    {
      "parameters": {
        "functionCode": "// Update Redis queue status and check for waiting dependencies\nconst Redis = require('ioredis');\nconst redis = new Redis({host: '127.0.0.1', port: 6379});\n\nconst filePath = $input.item.json.file_path;\nconst cloneId = $input.item.json.clone_id;\n\ntry {\n  // Mark file as completed\n  await redis.hset('file_tracking', filePath, 'completed');\n\n  // Check if any files were waiting on this one\n  const waitingFiles = await redis.smembers(`deps:${filePath}:waiting`);\n\n  if (waitingFiles.length > 0) {\n    console.log(`${waitingFiles.length} files were waiting on ${filePath}`);\n\n    // Remove the dependency for each waiting file\n    for (const waitingFile of waitingFiles) {\n      await redis.srem(`file:${waitingFile}:pending_deps`, filePath);\n\n      // Check if waiting file has no more pending deps\n      const remainingDeps = await redis.scard(`file:${waitingFile}:pending_deps`);\n      if (remainingDeps === 0) {\n        // Unblock the waiting file - add it back to queue with high priority\n        const taskData = await redis.hget('tasks:blocked', waitingFile);\n        if (taskData) {\n          await redis.zadd('queue:backend', 1, taskData); // Priority 1 = high\n          await redis.hdel('tasks:blocked', waitingFile);\n          console.log(`Unblocked file: ${waitingFile}`);\n        }\n      }\n    }\n\n    // Clear the waiting set\n    await redis.del(`deps:${filePath}:waiting`);\n  }\n\n  // Update clone stats\n  await redis.hset(`clone:${cloneId}:status`, 'last_completed', filePath);\n  await redis.hset(`clone:${cloneId}:status`, 'last_completed_at', Date.now());\n} catch (err) {\n  console.error('Redis error in update-queue-status:', err.message);\n} finally {\n  await redis.quit();\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    queue_updated: true\n  }\n};"
      },
      "id": "update-queue-status",
      "name": "Update Queue Status",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2050,
        500
      ]
    },
    {
      "parameters": {
        "functionCode": "// Trigger Galadriel for code review (optional, based on quality gate)\nconst Redis = require('ioredis');\nconst redis = new Redis({host: '127.0.0.1', port: 6379});\n\nconst filePath = $input.item.json.file_path;\nconst code = $input.item.json.result.code;\nconst cloneId = $input.item.json.clone_id;\n\ntry {\n  // Get quality gate settings\n  const qualityGateEnabled = await redis.hget('settings', 'quality_gate_enabled') || 'true';\n\n  if (qualityGateEnabled === 'true') {\n    // Queue for Galadriel review\n    await redis.publish('agent:Galadriel', JSON.stringify({\n      from: 'Gimli',\n      type: 'review_request',\n      clone_id: cloneId,\n      file_path: filePath,\n      code: code,\n      timestamp: Date.now()\n    }));\n\n    console.log(`Queued ${filePath} for Galadriel review`);\n  }\n\n  // Random 5% chance to trigger Pippin exploration\n  if (Math.random() < 0.05) {\n    await redis.publish('agent:Pippin', JSON.stringify({\n      from: 'Gimli',\n      type: 'exploration_opportunity',\n      clone_id: cloneId,\n      file_path: filePath,\n      context: 'Random exploration trigger after file completion'\n    }));\n    console.log(`Triggered Pippin exploration for ${filePath}`);\n  }\n} catch (err) {\n  console.error('Redis error in trigger-galadriel:', err.message);\n} finally {\n  await redis.quit();\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    galadriel_triggered: true\n  }\n};"
      },
      "id": "trigger-galadriel-review",
      "name": "Trigger Galadriel Review",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2250,
        500
      ]
    },
    {
      "parameters": {
        "functionCode": "// Signal completion and check for more work\nconst Redis = require('ioredis');\nconst redis = new Redis({host: '127.0.0.1', port: 6379});\n\nconst cloneId = $input.item.json.clone_id;\nconst hackathonId = $input.item.json.hackathon_id;\nconst filePath = $input.item.json.file_path;\n\nlet hasMoreWork = false;\nlet queueSize = 0;\n\ntry {\n  // Check queue size\n  queueSize = await redis.zcard('queue:backend');\n  hasMoreWork = queueSize > 0;\n\n  // Emit completion event\n  await redis.publish('events:file_completed', JSON.stringify({\n    hackathon_id: hackathonId,\n    clone_id: cloneId,\n    file_path: filePath,\n    queue_remaining: queueSize,\n    timestamp: Date.now()\n  }));\n\n  // Update clone status\n  if (hasMoreWork) {\n    await redis.hset(`clone:${cloneId}:status`, 'state', 'ready');\n  } else {\n    await redis.hset(`clone:${cloneId}:status`, 'state', 'idle');\n\n    // Check if all backend work is done\n    const fileTracking = await redis.hgetall('file_tracking');\n    const backendFiles = Object.entries(fileTracking)\n      .filter(([path]) => path.startsWith('backend/') || path.includes('/api/') || path.includes('/routes/'));\n    const allCompleted = backendFiles.every(([_, status]) => status === 'completed');\n\n    if (allCompleted) {\n      await redis.publish('events:backend_complete', JSON.stringify({\n        hackathon_id: hackathonId,\n        total_files: backendFiles.length,\n        timestamp: Date.now()\n      }));\n    }\n  }\n} catch (err) {\n  console.error('Redis error in signal-completion:', err.message);\n} finally {\n  await redis.quit();\n}\n\nreturn {\n  json: {\n    status: 'completed',\n    clone_id: cloneId,\n    hackathon_id: hackathonId,\n    file_path: filePath,\n    has_more_work: hasMoreWork,\n    queue_remaining: queueSize\n  }\n};"
      },
      "id": "signal-completion",
      "name": "Signal Completion",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2450,
        500
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.has_more_work }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-more-work",
      "name": "Check More Work",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2650,
        500
      ]
    },
    {
      "parameters": {
        "url": "http://127.0.0.1:5678/webhook/gimli-clone",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({clone_id: $json.clone_id, hackathon_id: $json.hackathon_id}) }}"
      },
      "id": "loop-more-work",
      "name": "Loop for More Work",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2850,
        400
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({status: 'clone_idle', clone_id: $json.clone_id, files_completed: 'all'}) }}"
      },
      "id": "respond-clone-idle",
      "name": "Respond - Clone Idle",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        2850,
        600
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({status: $json.status, clone_id: $json.clone_id, file_path: $json.file_path || 'n/a'}) }}"
      },
      "id": "respond-import-fix",
      "name": "Respond - Import Fix Pending",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        2050,
        300
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "gimli-fix-complete",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "fix-complete-webhook",
      "name": "Fix Complete Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        250,
        600
      ],
      "webhookId": "gimli-fix-complete"
    },
    {
      "parameters": {
        "functionCode": "// Resume from fix - write corrected code\nconst payload = $input.item.json.body;\n\nreturn {\n  json: {\n    clone_id: payload.clone_id,\n    hackathon_id: payload.hackathon_id,\n    result: {\n      file_path: payload.file_path,\n      code: payload.corrected_code,\n      language: payload.language || 'javascript'\n    },\n    import_validation: { valid: true, errors: [] },\n    fix_source: payload.fixed_by || 'Merry'\n  }\n};"
      },
      "id": "process-fix-complete",
      "name": "Process Fix Complete",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        450,
        600
      ]
    }
  ],
  "connections": {
    "Gimli Clone Webhook": {
      "main": [
        [
          {
            "node": "Initialize Clone & Get Task",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Clone & Get Task": {
      "main": [
        [
          {
            "node": "Check Queue Empty",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Queue Empty": {
      "main": [
        [
          {
            "node": "Respond - Queue Empty",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Gimli Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Gimli Context": {
      "main": [
        [
          {
            "node": "Call Gimli (Claude API)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Gimli (Claude API)": {
      "main": [
        [
          {
            "node": "Parse Gimli Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Gimli Output": {
      "main": [
        [
          {
            "node": "Validate Imports",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Imports": {
      "main": [
        [
          {
            "node": "Check Imports Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Imports Valid": {
      "main": [
        [
          {
            "node": "Route to Merry for Import Fix",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Write File to Container",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route to Merry for Import Fix": {
      "main": [
        [
          {
            "node": "Respond - Import Fix Pending",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write File to Container": {
      "main": [
        [
          {
            "node": "Update Queue Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Queue Status": {
      "main": [
        [
          {
            "node": "Trigger Galadriel Review",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger Galadriel Review": {
      "main": [
        [
          {
            "node": "Signal Completion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Signal Completion": {
      "main": [
        [
          {
            "node": "Check More Work",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check More Work": {
      "main": [
        [
          {
            "node": "Loop for More Work",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond - Clone Idle",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fix Complete Webhook": {
      "main": [
        [
          {
            "node": "Process Fix Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Fix Complete": {
      "main": [
        [
          {
            "node": "Write File to Container",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-12-19T00:00:00.000Z",
  "versionId": "1"
}